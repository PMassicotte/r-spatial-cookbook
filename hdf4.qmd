# HDF4

```{r}
library(terra)
library(ncdf4)
```

## NetCDF (Network Common Data Form)

Layers in the file can be listed using the `nc_open()` function:

```{r}
file <- fs::path("data", "avhrr-only-v2.20160503.nc")

f <- nc_open(file)
f
```

Opening a specific layer is done with the `ncvar_get()` function:

```{r}
names(f[["var"]])
sst <- ncvar_get(f, "sst")

dim(sst)

nc_close(f)
```

Here, we're extracting the sea surface temperature (SST) data and checking its dimensions. Always remember to close the NetCDF file after use.

## Open NetCDF file using `rast()`

The `terra` package provides an alternative method to work with NetCDF files. This creates a `SpatRaster` object, which is more memory-efficient for large datasets. It looks like the raster is rotated.

```{r}
r <- rast(file, lyrs = 1L)

r

plot(r)
```

We can rotate it back with the `rotate()` function:

```{r}
r <- rotate(r)

plot(r)
```

Converting to a data frame can be useful for certain types of analysis or visualization, but be cautious with large datasets as this can be memory-intensive.

```{r}
df <- as.data.frame(r)

head(df)
```

## Compare the values (WIP)

I am noticing that the values of `sst` and `df$`sst_zlev=0`` are not the same. I should investigate this further.

```{r}
# Validate if I have to transpose the `sst` matrix before comparing
waldo::compare(df$`sst_zlev=0`, as.vector(t(sst)), tolerance = 1e-3)
```

```{r}
# Check for missing values
sum(is.na(sst))

# Looks like there are no missing values in the data frame
sum(is.na(df$`sst_zlev=0`))

length(sst)
length(df$`sst_zlev=0`)

# Check data types
str(sst)
str(df$`sst_zlev=0`)

# Compare a subset of data
sst_subset <- sst[1:10, 1:10]
df_subset <- df$`sst_zlev=0`[1:100] # Adjust indexing as needed

# Compare the subsets
waldo::compare(sst_subset, df_subset, tolerance = 1e-3)
```
